# Some basic env setup used throughout config
IS_MAC=$([[ $(uname) != Darwin ]]; echo -n $?)
IS_LINUX=$([[ $(uname) != Linux ]]; echo -n $?)

# Enable hooks
typeset -gUa preexec_functions
typeset -gUa precmd_functions
typeset -gUa chpwd_functions

## smart urls
if [[ -o interactive ]]; then
  autoload -U url-quote-magic
  zle -N self-insert url-quote-magic

  # Colorize me
  autoload colors; colors;

  # Setup gpg to know what terminal is active for this session
  GPG_TTY=$(tty)
fi

HISTFILE=~/.zsh_history
HISTSIZE=10000
SAVEHIST=10000
REPORTTIME=60               # print elapsed time when more than 10 seconds

setopt NO_LIST_BEEP
setopt LOCAL_OPTIONS        # allow functions to have local options
setopt LOCAL_TRAPS          # allow functions to have local traps
setopt CORRECT
setopt NO_CORRECT_ALL       # Prevents asking 'correct git to .git' when at root
setopt COMPLETE_IN_WORD
setopt NO_ALWAYS_TO_END     # Don't got to end of word on completion from middle
setopt NO_LIST_AMBIGUOUS    # Don't auto complete until ambiguous
setopt COMPLETE_ALIASES     # Aliases as unique entities viable for completion
setopt NO_REC_EXACT         # Always ask if multiple matches exist with word

setopt AUTO_MENU
setopt LIST_ROWS_FIRST      # Order completion by row instead of column
setopt RC_EXPAND_PARAM      # Use arrays in in params to get multiple versions
setopt CLOBBER              # allow > to clobber and >> to append/create

setopt INTERACTIVE_COMMENTS # Allow comments when in an interactive shell
setopt NO_PRINT_EXIT_VALUE  # My zsh prompt tells me what the exit value was

setopt SHARE_HISTORY        # All my shells are like one hive mind, cool
setopt HIST_VERIFY          # Verity a history command before executing (sanity)
setopt HIST_IGNORE_ALL_DUPS # Don't record dupes in history
setopt HIST_REDUCE_BLANKS   # Remove blanks between arguments before saving
setopt HIST_IGNORE_SPACE    # Insert a space at start to prevent history of cmd
setopt HIST_NO_STORE        # Don't save the history command (fc -l) in history
setopt HIST_LEX_WORDS       # Parse history from file like it was on commandline

setopt CHECK_JOBS           # A little nag that jobs exist before quiting
setopt NO_HUP               # Used in combination with CHECK_JOBS
setopt AUTO_CONTINUE        # Disowned jobs begin to run again
setopt LONG_LIST_JOBS       # Obvious, longer list of jobs
setopt NO_NOTIFY            # For an easier to read terminal, wait till prompt
setopt NO_AUTO_RESUME       # Bad inference, I don't mean to resume jobs
setopt NO_POSIX_JOBS        # Sub shells have their own job lists
setopt NO_BG_NICE           # don't nice background tasks

setopt AUTO_CD              # Don't require using cd to cd
setopt AUTO_PUSHD           # every cd pushs onto the stack
setopt PUSHD_SILENT         # Silent cds since we pushd
setopt PUSHD_IGNORE_DUPS    # Ignore duplicate pushs
setopt PUSHD_TO_HOME        # Empty pushd is like cd

setopt NULL_GLOB            # No match return nil, used in $path
setopt EXTENDED_GLOB        # use regex style globing
setopt REMATCH_PCRE         # use perl regex matching for the =~ operator

setopt C_BASES              # Output non base 10 like C

setopt AUTO_PARAM_KEYS      # Neater prompt, deletes spaces after complete
setopt AUTO_PARAM_SLASH     # Params that a directories get a /

setopt MAGIC_EQUAL_SUBST    # option=arg can have arg path expanded
setopt PROMPT_SUBST         # Allow variable substitution in the prompt

## pager
export LESS="-Ri"
export PAGER=less
export LC_ALL='en_US.UTF-8'
export LANG='en_US.UTF-8'
export LC_CTYPE='en_US.UTF-8'

## grep
if [[ -o interactive ]]; then
  export GREP_OPTIONS='--color=auto'
  export GREP_COLOR='1;32'
else
  export GREP_OPTIONS='--color=never'
fi

export EDITOR='vim'

path=($HOME/.local/{s,}bin(/) $HOME/.bin(/) $HOME/.bin(@) /usr/texbin/(/) $path)
fpath=(~/.zsh/functions $fpath)
manpath=(/usr/local/share/man /usr/share/man $manpath)

# Load all of your custom configurations from custom/
function {
  local config_file
  for config_file (~/.zsh/envs/*) source $config_file
}

if [[ $IS_MAC -eq 1 ]]; then
  fignore+='.DS_Store'
  export __CF_USER_TEXT_ENCODING="$(printf '0x%X' $(id -u)):0x08000100:0"
fi

if [[ -o interactive ]]; then
  if [[ ! $TERM =~ ^screen ]]; then
    alias screen="screen -dRaA"
  else
    export TERM="screen-256color"
  fi
fi

# Remove duplicates in paths
typeset -gU path cdpath manpath fpath

if [[ -o interactive ]]; then
  # Turn off the retarded flow control
  command -v stty &> /dev/null && stty -ixon

  # Make a nice colored interactive prompt
  source ~/.zsh/vendor/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
  ZSH_HIGHLIGHT_STYLES[path]=none

  # # Add nice shortcuts like ci" to standard vi mode
  . ~/.zsh/functions/opp-install
  opp-install
  autoload opp

  # Color all stderr lines yellow only when interactive
  # The guard prevent a proliferation of processes when
  # using exec to replace the current shell with a fresh
  # instance
  if [[ -f "$HOME/.homebrew/lib/libstderred.dylib" ]]; then
    export STDERRED_ESC_CODE="$fg[red]"
    typeset -TgU DYLD_INSERT_LIBRARIES dyld_insert_libraries
    dyld_insert_libraries=($HOME/.homebrew/lib/libstderred.dylib(-.) $dyld_insert_libraries)
    export DYLD_INSERT_LIBRARIES
  elif [[ -f "$HOME/.local/lib/libstderred.so" ]]; then
    export STDERRED_ESC_CODE="$fg[red]"
    typeset -TgU LD_PRELOAD ld_preload
    ld_preload=($HOME/.local/lib/libstderred.dylib(-.) $ld_preload)
    export LD_PRELOAD
  else
    if [[ "$STDERR_COLORIZE" != $$ ]]; then
      if command -v colorize >& /dev/null; then
        exec 2>>(colorize $fg[yellow] $reset_color > /dev/tty &)
      else
        exec 2>>(while read line; do
          print ${fg[yellow]}$line$reset_color > /dev/tty; print -n $'\0'; done &)
      fi
      export STDERR_COLORIZE=$$
    fi
  fi
fi

# vim: set ft=zsh:
