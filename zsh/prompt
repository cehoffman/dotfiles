__prompt_mode_insert="%B%F{blue}i%{$reset_color%}"
__prompt_mode_cmd="%B%F{yellow}n%{$reset_color%}"
__prompt_mode=$__prompt_mode_insert
function zle-keymap-select {
  local prompt_was=$__prompt_mode

  if [[ "$KEYMAP" == 'vicmd' || "$KEYMAP" == 'opp' ]]; then
    __prompt_mode=$__prompt_mode_cmd
  else
    __prompt_mode=$__prompt_mode_insert
  fi

  # Only update the prompt if mode actually changed
  # This prevents the prompt from jumping up a line when
  # issuing commands that go through several keymaps, e.g.
  # cc will go vicmd -> opp -> main
  [[ $__prompt_mode != $prompt_was ]] && zle .reset-prompt
}

function __reset_prompt_mode_precmd() {
  __prompt_mode=$__prompt_mode_insert
}
precmd_functions+=__reset_prompt_mode_precmd

zle -N zle-keymap-select

autoload -Uz regexp-replace

function update_rprompt() {
  # Prepare to reprint the prompt
  local rprompt=${(%%)RPROMPT}
  local rpromptsize=$rprompt

  # Strip color codes from prompt to get real size
  unsetopt RE_MATCH_PCRE
  regexp-replace rpromptsize "\[([0-9]{1,2}(;[0-9]{1,2}(;[0-9]{1,3})?)?)?[m|K]"

  # Go back to the start of current prompt and reprint it
  echo -ne "\e[A\e[$(( $COLUMNS - $#rpromptsize ))G$rprompt\e[B\e[G"
}
preexec_functions+=update_rprompt

function {
  local red="%b%F{red}"
  local bold_red="%B%F{red}"
  local blue="%b%F{blue}"
  local black="%b%F{237}"
  local bold_black="%B%F{black}"
  local yellow="%b%F{yellow}"
  local bold_yellow="%B%F{yellow}"
  local white="%b%F{white}"
  local magenta="%b%F{magenta}"
  local bold_magenta="%B%F{magenta}"
  local cyan="%b%F{cyan}"
  local bold_cyan="%B%F{cyan}"
  local green="%b%F{green}"
  local reset="%s%b%k%f"

  local ul="%(!.$red.$black)‚îå"
  local ll="%(!.$red.$black)‚îî"
  local ur="%(!.$red.$black)‚îê"
  local lr="%(!.$red.$black)‚îò"
  local open="%(!.$red‚îÄ‚ù∞.$black‚îÄ‚¶Ö)"
  local close="%(!.$red‚ù±.$black‚¶Ü)‚îÄ"

  local name="%(!.$bold_magenta.$blue)%n$black"
  local last_exit="${bold_red}%(?..E:%? )"

  PROMPT="$ul$open$name@$red%m$reset:%\$_pr_pwdlen<‚Ä¶<\$_pr_pwd%<<$close\$_pr_fillwidth\${_pr_extras:+${(qqq)open}${(qqq)reset}\${(j: :)_pr_extras}${(qqq)close}${(qqq)ur}}
$ll$open$last_exit\${(j: :)_pr_short_extras}\${_pr_short_extras:+ }\$__prompt_mode$close$reset "
  RPROMPT=" $open$reset%D{%H:%M} ${bold_black}on $reset%D{%a %b %d}$close\${_pr_extras:+${(qqq)lr}}$reset"
  PS2="(!.$red.$bold_black)‚îú$open$bold_cyan%_$close$reset "
  PROMPT_EOL_MARK="%b%F{77}¬ß$reset"
}

autoload -Uz vcs_info

zstyle ':vcs_info:*' stagedstr '%F{green}‚ú§'
zstyle ':vcs_info:*' unstagedstr '%F{yellow}‚ô∫'
zstyle ':vcs_info:*' untrackedstr '%B%F{red}‚úΩ%%b'
zstyle ':vcs_info:*' aheadstr '%B%F{green}‚Üë%x'
zstyle ':vcs_info:*' behindstr '%B%F{red}‚Üì%z'
zstyle ':vcs_info:*' divergedstr '%B%F{magenta}‚Üì%x‚Üë%z'
zstyle ':vcs_info:*' check-for-changes true
# zstyle ':vcs_info:(sv[nk]|bzr):*' branchformat '%%b%F{black}%b:%F{magenta}%r'
# zstyle ':vcs_info:git:*' branchformat '%F{cyan}%b'
zstyle ':vcs_info:*' use-prompt-escapes true
zstyle ':vcs_info:*' max-exports 2
zstyle ':vcs_info:*' enable git

# Define some hooks for the git backend to collect some more information on the repo
# zstyle ':vcs_info:*+*:*' debug true
zstyle ':vcs_info:git+pre-get-data:*' hooks git-untracked
zstyle ':vcs_info:git+set-message:*' hooks git-message

# The first prompt info is for width calculation so no colors, 2nd is like first but with colors
# and the 3rd is the short display of vcs state - it is overridden in the git_message hook
zstyle ':vcs_info:git:*' symbol '%F{cyan}¬±'
zstyle ':vcs_info:git:*' formats '%%b%v:%b' '%%b%v:%c%u%o%w%y%d'
zstyle ':vcs_info:git:*' actionformats '%%b%v:%b%F{white}(%B%a%%b)' '%%b%v:%c%u%o%w%y%d%F{white}(%B%a%%b)'

function +vi-git-untracked() {
  # To get if there are any staged changes
  # $(git diff-index --quite --cached HEAD)
  # To get if there are any unstaged changes (0 == no difference, 1 == difference)
  # $(git diff-files --quiet)
  user_data[ahead]=$(git rev-list HEAD@{upstream}..HEAD 2> /dev/null)
  user_data[behind]=$(git rev-list HEAD..HEAD@{upstream} 2> /dev/null)
  [[ -z $user_data[ahead] || -z $user_data[behind] ]]; user_data[diverged]=$?
  user_data[untracked]=$(git status --porcelain 2> /dev/null | grep "^??" &> /dev/null ; echo $(( ! $? )) )
}

function +vi-git-message {
  local format
  # Pick which format string is needed
  if [[ -n $hook_com[action] ]]; then
    zstyle -a ":vcs_info:$hook_com[vcs]:*" actionformats format
  else
    zstyle -a ":vcs_info:$hook_com[vcs]:*" formats format
  fi
  format=$format[$(( $1 + 1))]

  [[ -z $format ]] && return

  local -a escapes
  local -A map
  map=('o' diverged 'w' ahead 'x' ahead_count 'y' behind 'z' behind_count
       'd' untracked 'v' vcs_symbol 'b' branch 'a' action 'R' base 'r'
       base-name 'S' subdir 'c' staged 'u' unstaged 'i' revision 'm' misc
       's' vcs)
  escapes=${(j::)${(k)map[*]}}

  # Get the custom symbol to represent this vcs system
  zstyle -s ":vcs_info:$hook_com[vcs]:*" symbol 'hook_com[vcs_symbol]'

  # Only load the untracked string if needed
  if [[ $user_data[untracked] -eq 1 ]]; then
    zstyle -s ":vcs_info:$hook_com[vcs]:*" untrackedstr 'hook_com[untracked]'
  fi

  # Load upstream statuses
  if [[ -n $user_data[ahead] ]]; then
    zstyle -s ":vcs_info:$hook_com[vcs]:*" aheadstr 'hook_com[ahead]'
    hook_com[ahead_count]=${(w)#user_data[ahead]}
  fi
  if [[ -n $user_data[behind] ]]; then
    zstyle -s ":vcs_info:$hook_com[vcs]:*" behindstr 'hook_com[behind]'
    hook_com[behind_count]=${(w)#user_data[behind]}
  fi

  # When diverged remove the behind and ahead strings because diverged
  # will take precedence
  if [[ $user_data[diverged] -eq 1 ]]; then
    zstyle -s ":vcs_info:$hook_com[vcs]:*" divergedstr 'hook_com[diverged]'
    unset "hook_com[ahead]"
    unset "hook_com[behind]"
  fi

  # Build the replacement message ourself
  hook_com[message]=$format
  local temp
  while true; do
    # Store a temp copy of message to allow early breakout of loop
    temp=$hook_com[message]

    # Replace all escapes with actuall values
    hook_com[message]=${hook_com[message]//(#b)([^\%])\%([$escapes])/$match[1]$hook_com[$map[$match[2]]]}
    # For if the pcre extension ever supports uft-8 chars...
    # regexp-replace "hook_com[message]" "(?<!%)%([${(j::)${(k)map[*]}}])" '$hook_com[$map[$match[1]]]'

    # Exit early if not changes occuring
    [[ $hook_com[message] = $temp ]] && break
  done
  hook_com[message]=${hook_com[message]//\%\%/\%}

  ret=1
}

# Initialize the vcs information on each prompt
precmd_functions+=vcs_info

function _prompt_precmd {
  # These hold a variable list of extra information depending on context. These
  # arrays hold each piece of information that will be displayed in the top
  # right prompt.
  local tempinfo
  typeset -ga _pr_extras
  typeset -ga _pr_short_extras
  _pr_short_extras=()
  _pr_extras=()

  # Reinitialize the global variables that will be substitued into the
  # prompt when it is displayed.
  typeset -g _pr_pwd=''
  typeset -g _pr_pwdlen=''
  typeset -g _pr_fillwidth=''

  if [[ -n $vcs_info_msg_0_ ]]; then
    _pr_extras+=$vcs_info_msg_0_
    _pr_short_extras+=$vcs_info_msg_1_
  fi

  _pr_extras+="%{$fg_no_bold[magenta]%}P:$(process-tree)"

  if command -v rvm-prompt > /dev/null; then
    _pr_extras+="%{$fg_no_bold[red]%}R:$(rvm-prompt v g)"
  fi

  if command -v rbenv > /dev/null; then
    _pr_extras+="%{$fg_no_bold[red]%}R:$(rbenv version-name)"
  fi

  if [[ $(jobs | wc -l) > 0 ]]; then
    tempinfo="%{$fg_no_bold[cyan]%}J:%j"
    _pr_extras+=$tempinfo
    _pr_short_extras+=$tempinfo
  fi

  if [[ $IS_MAC = 1 ]]; then
    local output; output=$(ioreg -rc AppleSmartBattery)
    if [[ -n $output ]]; then
      local batcolor
      local batmax
      local batshort

      [[ $output =~ "MaxCapacity.*?(\d+)" ]]
      batmax=$match[1]
      [[ $output =~ "CurrentCapacity.*?(\d+)" ]]
      ((tempinfo = ($match[1] * 100) / $batmax))
      [[ $match[1] -lt $batmax ]] && ((tempinfo = $tempinfo + 1))

      if [[ $tempinfo -gt 85 ]]; then
        batcolor="%{$fg_bold[green]%}"
      elif [[ $tempinfo -gt 65 ]]; then
        batcolor="%{$fg_no_bold[green]%}"
      elif [[ $tempinfo -gt 45 ]]; then
        batcolor="%{$fg_no_bold[yellow]%}"
      elif [[ $tempinfo -gt 25 ]]; then
        batcolor="%{$fg_bold[yellow]%}"
      elif [[ $tempinfo -gt 10 ]]; then
        batcolor="%{$fg_no_bold[red]%}"
      else
        batcolor="%{$fg_bold[red]%}"
      fi

      if [[ $output =~ "IsCharging.*?Yes" ]]; then
        batshort="$batcolor‚ö°:‚Üë%{$reset_color%}"
      elif [[ $output =~ "ExternalConnected.*?No" ]]; then
        batshort="$batcolor‚ö°:‚Üì%{$reset_color%}"
      fi

      if [[ -z $batshort ]]; then
        tempinfo="‚ö°:$tempinfo%%"
      else
        tempinfo="‚ö°:$tempinfo%%"

        [[ $output =~ "TimeRemaining.*?(\d+)" ]]
        tempinfo="$tempinfo($(printf "%02i:%02i" $(($match[1] / 60)) $(($match[1] - ($match[1] / 60 ) * 60))))"
      fi

      _pr_extras+="$batcolor$tempinfo"
      [[ -n $batshort ]] && _pr_short_extras+=$batshort
    fi
  fi

  # Color the path differently when the current directory is/isn't writeable
  _pr_pwd=${PWD/$HOME/\~}
  local pwdsize=$#_pr_pwd
  if [[ -w $PWD ]]; then
    _pr_pwd="%{$reset_color%}$_pr_pwd"
  else
    _pr_pwd="%{$fg_bold[black]%}$_pr_pwd%{$reset_color%}"
  fi

  # Calculate how much the fill size will need to be or if the path will
  # need to be truncated to fit the first line of prompt
  # local promptsize=${#${(%):---(%n@%m:)---(${(j: :)infos})--}}
  local promptsize
  function calc_promptsize() {
    _pr_fillwidth=''
    promptsize=${(S%%)${(e)PROMPT}//(\%([KF1]|)\{*\}|\%[BbkfsS])}
    promptsize=${${(f)promptsize}[1]}
    promptsize=$(( $#promptsize - $pwdsize + 1 ))
  }
  calc_promptsize

  for tempinfo in {1..$#extras}; do
    if (($COLUMNS - $promptsize > 5)); then
      break
    else
      # Assumes that the last item put on the list is the most imporant
      # one to try and keep so shifts the earlier ones out
      _pr_extras=($_pr_extras[1,-2])
      calc_promptsize
    fi
  done

  if (($promptsize + $pwdsize > $COLUMNS)); then
    ((_pr_pwdlen = $COLUMNS - $promptsize - 1))
  else
    _pr_fillwidth="${(l.(($COLUMNS - ($promptsize + $pwdsize))).. .)}"
  fi
}
precmd_functions+=_prompt_precmd

# vim: ft=zsh
