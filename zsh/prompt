__prompt_mode_insert="%{$fg_bold[white]%}i%{$reset_color%}"
__prompt_mode_cmd="%{$fg_bold[white]%}n%{$reset_color%}"
__prompt_mode=$__prompt_mode_insert
function zle-keymap-select {
  if [[ "$KEYMAP" == 'vicmd' || "$KEYMAP" == 'cmd' ]]; then
    __prompt_mode=$__prompt_mode_cmd
  else
    __prompt_mode=$__prompt_mode_insert
  fi
  zle reset-prompt
}

function my-accept-line {
    __prompt_mode=$__prompt_mode_insert
  zle .accept-line
  zle reset-prompt
}

bindkey -M vicmd '^M' my-accept-line
bindkey -M vicmd '^J' my-accept-line
zle -N my-accept-line
zle -N zle-keymap-select

function setup_prompt() {
  local red="%{$fg_no_bold[red]%}"
  local bold_red="%{$fg_bold[red]%}"
  local blue="%{$fg_no_bold[blue]%}"
  local bold_black="%{$fg_bold[black]%}"
  local yellow="%{$fg_no_bold[yellow]%}"
  local bold_yellow="%{$fg_bold[yellow]%}"
  local white="%{$fg_no_bold[white]%}"
  local magenta="%{$fg_no_bold[magenta]%}"
  local bold_magenta="%{$fg_bold[magenta]%}"
  local cyan="%{$fg_no_bold[cyan]%}"
  local bold_cyan="%{$fg_bold[cyan]%}"
  local green="%{$fg_no_bold[green]%}"
  local reset="%{$reset_color%}"

  local ul="%(!.$red.$bold_black)┌"
  local ur="%(!.$red.$bold_black)┐"
  local ll="%(!.$red.$bold_black)└"
  local lr="%(!.$red.$bold_black)┘"
  local open="%(!.$red─[.$bold_black─()"
  local close="%(!.$red].$bold_black%))─"

  local name="%(!.$bold_magenta.$blue)%n$bold_black"
  local last_exit="${bold_red}%(?..E:%? )"

  PROMPT="$ul$open$name@$red%m$reset:%\$_pr_pwdlen<…<\$_pr_pwd%<<$close\$_pr_fillwidth\${_pr_extras:+${(qqq)open}\$_pr_extras${(qqq)close}${(qqq)ur}}
$ll$open$last_exit\${(j: :)_pr_short_extras}\${_pr_short_extras:+ }\$__prompt_mode$close$reset "
  RPROMPT=" $open$reset%D{%H:%M} ${bold_black}on $reset%D{%a %b %d}$close\${_pr_extras:+${(qqq)lr}}\$([[ ! -n \$_pr_extras ]] && echo -n ─)$reset"
  PS2="(!.$red.$bold_black)├$open$bold_cyan%_$close$reset "
}
setup_prompt
unfunction setup_prompt

function _prompt_precmd {
  # These arrays hold each piece of information that will be displayed
  # in the top right prompt. Because the width calculation is confused
  # by the colors in the prompt the infos array stores an uncolored version
  # to use when calculation the fill width
  local -a infos
  local -a colorinfos
  local tempinfo

  # Reinitialize the global variables that will be substitued into the
  # prompt when it is displayed. _pr_short_extras is like the infos
  # above and holds a list of extra information to be put into the lower
  # left of the prompt when calculating each piece of extra info in this setup
  typeset -ga _pr_short_extras
  typeset -g _pr_pwd=''
  typeset -g _pr_pwdlen=''
  typeset -g _pr_fillwidth=''
  typeset -g _pr_extras=''

  _pr_short_extras=()

  if [[ -n $__pr_git_branch ]]; then
    tempinfo="±:$__pr_git_branch"
    infos+=$tempinfo
    colorinfos+="%{$fg_no_bold[cyan]%}$tempinfo"
    _pr_short_extras+="%{$fg_no_bold[cyan]%}±:%{$fg_bold[magenta]%}$__pr_git_status%{$fg_no_bold[red]%}$__pr_git_dirty%{$fg_no_bold[green]%}$__pr_git_clean"
  fi

  if [[ -n $rvm_version ]]; then
    tempinfo="R:$(rvm-prompt v g)"
    infos+=$tempinfo
    colorinfos+="%{$fg_no_bold[red]%}$tempinfo"
  fi

  if [[ $(jobs | wc -l) > 0 ]]; then
    tempinfo="J:%j"
    infos+=$tempinfo
    tempinfo="%{$fg_no_bold[cyan]%}$tempinfo"
    colorinfos+=$tempinfo
    _pr_short_extras+=$tempinfo
  fi

  if [[ $IS_MAC = 1 ]]; then
    local output; output=$(ioreg -rc AppleSmartBattery)
    local batcolor
    local batmax

    [[ $output =~ "MaxCapacity.*?(\d+)" ]]
    batmax=$match[1]
    [[ $output =~ "CurrentCapacity.*?(\d+)" ]]
    ((tempinfo = ($match[1] * 100) / $batmax))
    [[ $match[1] -lt $batmax ]] && ((tempinfo = $tempinfo + 1))

    if [[ $tempinfo -gt 85 ]]; then
      batcolor="%{$fg_bold[green]%}"
    elif [[ $tempinfo -gt 65 ]]; then
      batcolor="%{$fg_no_bold[green]%}"
    elif [[ $tempinfo -gt 45 ]]; then
      batcolor="%{$fg_no_bold[yellow]%}"
    elif [[ $tempinfo -gt 25 ]]; then
      batcolor="%{$fg_bold[yellow]%}"
    elif [[ $tempinfo -gt 10 ]]; then
      batcolor="%{$fg_no_bold[red]%}"
    else
      batcolor="%{$fg_bold[red]%}"
    fi

    if [[ $tempinfo -eq 100 ]]; then
      tempinfo="⚡:$tempinfo%%"
    else
      tempinfo="⚡:$tempinfo%%"

      [[ $output =~ "TimeRemaining.*?(\d+)" ]]
      tempinfo="$tempinfo($(printf "%02i:%02i" $(($match[1] / 60)) $(($match[1] - ($match[1] / 60 ) * 60))))"
    fi

    if [[ $output =~ "IsCharging.*?Yes" ]]; then
      _pr_short_extras+="$batcolor⚡:↑%{$reset_color%}"
    elif [[ $output =~ "ExternalConnected.*?No" ]]; then
      _pr_short_extras+="$batcolor⚡:↓%{$reset_color%}"
    fi

    infos+=$tempinfo
    colorinfos+="$batcolor$tempinfo"
  fi

  # Color the path differently when the current directory is/isn't writeable
  if [[ -w $PWD ]]; then
    _pr_pwd="%{$reset_color%}${(%):-%~}"
  else
    _pr_pwd="%{$fg_bold[black]%}${(%):-%~}%{$reset_color%}"
  fi

  # Calculate how much the fill size will need to be or if the path will
  # need to be truncated to fit the first line of prompt
  local promptsize=${#${(%):---(%n@%m:)---(${(j: :)infos})--}}
  local pwdsize=${#${(%):-%~}}

  for tempinfo in {1..$#infos}; do
    if (($COLUMNS - $promptsize > 5)); then
      break
    else
      # Assumes that the last item put on the list is the most imporant
      # one to try and keep so shifts the earlier ones out
      infos=($infos[1,-2])
      colorinfos=($colorinfos[1,-2])
      promptsize=${#${(%):---(%n@%m:)---(${(j: :)infos})--}}
    fi
  done

  if (($promptsize + $pwdsize > $COLUMNS)); then
    ((_pr_pwdlen = $COLUMNS - $promptsize - 1))
  else
    _pr_fillwidth="${(l.(($COLUMNS - ($promptsize + $pwdsize))).. .)}"
  fi

  (($#infos > 0)) && _pr_extras="${(j: :)colorinfos}%{$reset_color%}"
}
precmd_functions+=_prompt_precmd

# git theming
ZSH_THEME_GIT_PROMPT_AHEAD="↑"
ZSH_THEME_GIT_PROMPT_DIVERGED="⬍"
ZSH_THEME_GIT_PROMPT_BEHIND="↓"
ZSH_THEME_GIT_PROMPT_CLEAN="✔"
ZSH_THEME_GIT_PROMPT_DIRTY="✘"

# vim: ft=zsh
