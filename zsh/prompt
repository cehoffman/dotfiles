__prompt_mode_insert="%B%F{blue}i%{$reset_color%}"
__prompt_mode_cmd="%B%F{yellow}n%{$reset_color%}"
__prompt_mode=$__prompt_mode_insert
function zle-keymap-select {
  local prompt_was=$__prompt_mode

  if [[ "$KEYMAP" == 'vicmd' || "$KEYMAP" == 'opp' ]]; then
    __prompt_mode=$__prompt_mode_cmd
  else
    __prompt_mode=$__prompt_mode_insert
  fi

  # Only update the prompt if mode actually changed
  # This prevents the prompt from jumping up a line when
  # issuing commands that go through several keymaps, e.g.
  # cc will go vicmd -> opp -> main
  [[ $__prompt_mode != $prompt_was ]] && zle .reset-prompt
}

function __reset_prompt_mode_precmd() {
  __prompt_mode=$__prompt_mode_insert
}
precmd_functions+=__reset_prompt_mode_precmd

autoload -Uz regexp-replace
function update_time() {
  local colorprompt=${(%%)RPROMPT}
  local prompt=$colorprompt
  setopt norematchpcre
  regexp-replace prompt "\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]"

  echo -ne "\e[A\e[$(( $COLUMNS - $#prompt ))G$colorprompt\e[B\e[G"
}
preexec_functions+=update_time

zle -N zle-keymap-select

function {
  local red="%b%F{red}"
  local bold_red="%B%F{red}"
  local blue="%b%F{blue}"
  local bold_black="%B%F{black}"
  local yellow="%b%F{yellow}"
  local bold_yellow="%B%F{yellow}"
  local white="%b%F{white}"
  local magenta="%b%F{magenta}"
  local bold_magenta="%B%F{magenta}"
  local cyan="%b%F{cyan}"
  local bold_cyan="%B%F{cyan}"
  local green="%b%F{green}"
  local reset="%{$reset_color%}"

  local ul="%(!.$red.$bold_black)‚îå"
  local ur="%(!.$red.$bold_black)‚îê"
  local ll="%(!.$red.$bold_black)‚îî"
  local lr="%(!.$red.$bold_black)‚îò"
  local open="%(!.$red‚îÄ‚ù∞.$bold_black‚îÄ‚é®)"
  local close="%(!.$red‚ù±.$bold_black‚é¨)‚îÄ"

  local name="%(!.$bold_magenta.$blue)%n$bold_black"
  local last_exit="${bold_red}%(?..E:%? )"

  PROMPT="$ul$open$name@$red%m$reset:%\$_pr_pwdlen<‚Ä¶<\$_pr_pwd%<<$close\$_pr_fillwidth\${_pr_extras:+${(qqq)open}\$_pr_extras${(qqq)close}${(qqq)ur}}
$ll$open$last_exit\${(j: :)_pr_short_extras}\${_pr_short_extras:+ }\$__prompt_mode$close$reset "
  RPROMPT=" $open$reset%D{%H:%M} ${bold_black}on $reset%D{%a %b %d}$close\${_pr_extras:+${(qqq)lr}}$reset"
  PS2="(!.$red.$bold_black)‚îú$open$bold_cyan%_$close$reset "
  PROMPT_EOL_MARK="%b%F{77}¬ß$reset"

}

autoload -Uz vcs_info

zstyle ':vcs_info:*' stagedstr '‚ú§'
zstyle ':vcs_info:*' unstagedstr 'ùùô'
zstyle ':vcs_info:*' check-for-changes true
# zstyle ':vcs_info:(sv[nk]|bzr):*' branchformat '%%b%F{black}%b:%F{magenta}%r'
# zstyle ':vcs_info:git:*' branchformat '%F{cyan}%b'
zstyle ':vcs_info:*' use-prompt-escapes true
zstyle ':vcs_info:*' max-exports 3
zstyle ':vcs_info:*' enable git

# Define some hooks for the git backend to collect some more information on the repo
zstyle ':vcs_info:git+pre-get-data:*' hooks git_untracked
zstyle ':vcs_info:git+set-message:*' hooks git_message

# The first prompt info is for width calculation so no colors, 2nd is like first but with colors
# and the 3rd is the short display of vcs state - it is overridden in the git_message hook
zstyle ':vcs_info:git:*' formats '¬±:%b' '%%b%F{cyan}¬±:%b' "%%b%F{cyan}¬±:%F{green}%c%F{yellow}%u"

function +vi-git_untracked() {
  # To get if there are any staged changes
  # $(git diff-index --quite --cached HEAD)
  # To get if there are any unstaged changes (0 == no difference, 1 == difference)
  # $(git diff-files --quiet)
  user_data[ahead]=$(git rev-list HEAD@{upstream}..HEAD 2> /dev/null)
  user_data[behind]=$(git rev-list HEAD..HEAD@{upstream} 2> /dev/null)
  [[ -z $user_data[ahead] || -z $user_data[behind] ]]; user_data[diverged]=$?
  [[ $(git status --porcelain) =~ "^[?]{2}" ]]; user_data[untracked]=$(( ! $? ))
}

function +vi-git_message {
  case $1 in
    # 0)
    #   hook_com[message]="¬±:$hook_com[branch]$hook_com[staged]$hook_com[unstaged]"
    #   hook_com[message]="${user_data[diverged]}"
    #   hook_com[misc]='T‚úò'‚éè‚éê‚éë‚éí‚èÖ‚ëÇ‚óâ‚óè‚ñ≤‚ñº‚ëÇ‚Üï‚áï‚á≥‚¨ç‚•å‚•ç‚•è‚•ë‚•Æ‚¨•
    #   ;;
    2)
      # Setup the marker for how local repo compares to upstream
      if [[ $user_data[diverged] -eq 1 ]]; then
        hook_com[message]+='‚¨ç%b' # ‚¨•
      elif [[ -n $user_data[ahead] ]]; then
        hook_com[message]+="‚Üë%b${(w)#user_data[ahead]}" # ‚ñ≤
      elif [[ -n $user_data[behind] ]]; then
        hook_com[message]+="‚Üì%b${(w)#user_data[behind]}" # ‚ñº
      fi

      # Mark how the status of untracked files is fairing
      [[ $user_data[untracked] -eq 1 ]] && hook_com[message]+='%F{red}x'

      if [[ -n $hook_com[staged] || -n $hook_com[unstaged] || -n $hook_com[message] ]]; then
        hook_com[message]=":%F{green}$hook_com[staged]%B%F{yellow}$hook_com[unstaged]%F{magenta}$hook_com[message]"
      fi

      hook_com[message]="%b%F{cyan}¬±$hook_com[message]"

      # Make the new message take effect
      ret=1
      ;;
  esac
}

# Initialize the vcs information on each prompt
precmd_functions+=vcs_info

function _prompt_precmd {
  # These arrays hold each piece of information that will be displayed
  # in the top right prompt. Because the width calculation is confused
  # by the colors in the prompt the infos array stores an uncolored version
  # to use when calculation the fill width
  local -a infos
  local -a colorinfos
  local tempinfo

  # Reinitialize the global variables that will be substitued into the
  # prompt when it is displayed. _pr_short_extras is like the infos
  # above and holds a list of extra information to be put into the lower
  # left of the prompt when calculating each piece of extra info in this setup
  typeset -ga _pr_short_extras
  typeset -g _pr_pwd=''
  typeset -g _pr_pwdlen=''
  typeset -g _pr_fillwidth=''
  typeset -g _pr_extras=''

  _pr_short_extras=()

  if [[ -n $vcs_info_msg_0_ ]]; then
    infos+=$vcs_info_msg_0_
    colorinfos+=$vcs_info_msg_1_
    _pr_short_extras+=$vcs_info_msg_2_
  fi

  if [[ -n $rvm_version ]]; then
    tempinfo="R:$(rvm-prompt v g)"
    infos+=$tempinfo
    colorinfos+="%{$fg_no_bold[red]%}$tempinfo"
  fi

  if [[ $(jobs | wc -l) > 0 ]]; then
    tempinfo="J:%j"
    infos+=$tempinfo
    tempinfo="%{$fg_no_bold[cyan]%}$tempinfo"
    colorinfos+=$tempinfo
    _pr_short_extras+=$tempinfo
  fi

  if [[ $IS_MAC = 1 ]]; then
    local output; output=$(ioreg -rc AppleSmartBattery)
    if [[ -n $output ]]; then
      local batcolor
      local batmax

      [[ $output =~ "MaxCapacity.*?(\d+)" ]]
      batmax=$match[1]
      [[ $output =~ "CurrentCapacity.*?(\d+)" ]]
      ((tempinfo = ($match[1] * 100) / $batmax))
      [[ $match[1] -lt $batmax ]] && ((tempinfo = $tempinfo + 1))

      if [[ $tempinfo -gt 85 ]]; then
        batcolor="%{$fg_bold[green]%}"
      elif [[ $tempinfo -gt 65 ]]; then
        batcolor="%{$fg_no_bold[green]%}"
      elif [[ $tempinfo -gt 45 ]]; then
        batcolor="%{$fg_no_bold[yellow]%}"
      elif [[ $tempinfo -gt 25 ]]; then
        batcolor="%{$fg_bold[yellow]%}"
      elif [[ $tempinfo -gt 10 ]]; then
        batcolor="%{$fg_no_bold[red]%}"
      else
        batcolor="%{$fg_bold[red]%}"
      fi

      if [[ $tempinfo -eq 100 ]]; then
        tempinfo="‚ö°:$tempinfo%%"
      else
        tempinfo="‚ö°:$tempinfo%%"

        [[ $output =~ "TimeRemaining.*?(\d+)" ]]
        tempinfo="$tempinfo($(printf "%02i:%02i" $(($match[1] / 60)) $(($match[1] - ($match[1] / 60 ) * 60))))"
      fi

      if [[ $output =~ "IsCharging.*?Yes" ]]; then
        _pr_short_extras+="$batcolor‚ö°:‚Üë%{$reset_color%}"
      elif [[ $output =~ "ExternalConnected.*?No" ]]; then
        _pr_short_extras+="$batcolor‚ö°:‚Üì%{$reset_color%}"
      fi

      infos+=$tempinfo
      colorinfos+="$batcolor$tempinfo"
    fi
  fi

  # Color the path differently when the current directory is/isn't writeable
  local collapsed_path=${PWD/$HOME/\~}
  if [[ -w $PWD ]]; then
    _pr_pwd="%{$reset_color%}${collapsed_path}"
  else
    _pr_pwd="%{$fg_bold[black]%}${collapsed_path}%{$reset_color%}"
  fi

  # Calculate how much the fill size will need to be or if the path will
  # need to be truncated to fit the first line of prompt
  local promptsize=${#${(%):---(%n@%m:)---(${(j: :)infos})--}}
  local pwdsize=${#${collapsed_path}}

  for tempinfo in {1..$#infos}; do
    if (($COLUMNS - $promptsize > 5)); then
      break
    else
      # Assumes that the last item put on the list is the most imporant
      # one to try and keep so shifts the earlier ones out
      infos=($infos[1,-2])
      colorinfos=($colorinfos[1,-2])
      promptsize=${#${(%):---(%n@%m:)---(${(j: :)infos})--}}
    fi
  done

  if (($promptsize + $pwdsize > $COLUMNS)); then
    ((_pr_pwdlen = $COLUMNS - $promptsize - 1))
  else
    _pr_fillwidth="${(l.(($COLUMNS - ($promptsize + $pwdsize))).. .)}"
  fi

  (($#infos > 0)) && _pr_extras="${(j: :)colorinfos}%{$reset_color%}"
}
precmd_functions+=_prompt_precmd

# vim: ft=zsh
