#!/usr/bin/env luajit
shell = {}

function shell.escape(...)
 local command = type(...) == 'table' and ... or { ... }
 for i, s in ipairs(command) do
  s = (tostring(s) or ''):gsub('"', '\\"')
  if s:find '[^A-Za-z0-9_."/-]' then
   s = '"' .. s .. '"'
  elseif s == '' then
   s = '""'
  end
  command[i] = s
 end
 return table.concat(command, ' ')
end

function shell.lines(...)
 return assert(io.popen(shell.escape(...) .. ' 2>&1')):lines()
end

function string:split(pat)
  pat = pat or '%s+'
  local idx, g = 1, self:gmatch("()(" .. pat .. ")")
  local function next(start, seps, sep)
    idx = sep and seps + #sep
    return self:sub(start, (seps or 0) - 1)
  end
  return function() if idx then return next(idx, g()) end end
end

function math.round(val, step)
  step = step or 1
  return math.floor(((val + step / 2) / step) * step)
end

table.unpack = unpack or table.unpack
local ffi = require "ffi"
setmetatable(_G, {__index = ffi.C})
ffi.cdef "int usleep(uint64_t)"

local function sum(t)
  local sum = 0
  for i, val in pairs(t) do sum = sum + val end
  return sum
end

local top = {}
setmetatable(top, {
  __index = function(self, k)
    for line in shell.lines{'top', '-R', '-F', '-l1', '-n0', '-s0'} do
      local key, value = line:match('^([%w%s]+):%s*(.+)')
      if key then self[key:lower()] = value end
    end

    -- don't call top again by accident
    setmetatable(self, {})

    return self[k]
  end
})

local function usage()
  local stat = io.open('/proc/stat', 'r')
  if stat then
    local diff, prev = {}, {}

    for i = 1, 0, -1 do
      for line in stat:lines() do
        local cpu, stats = line:find("^cpu%s+%d+")
        if not cpu then goto next end

        stats = {}
        for stat in line:split() do table.insert(stats, tonumber(stat)) end

        diff.idle = stats[4] - (prev.idle or 0)
        diff.total = sum(stats) - (prev.total or 0)
        diff.usage = (diff.total - diff.idle) / diff.total

        prev.idle, prev.total = diff.idle, diff.total

        ::next::
        break
      end

      usleep(i * 1000000)
      stat:seek('set', 0)
    end

    stat:close()
    return diff.usage
  else
    for str in top["cpu usage"]:split("%s*,%s*") do
      local stat, name = str:match("([%d%.]+)%%%s+(%w+)")
      if name == "idle" then return 1 - stat / 100 end
    end
  end
end

local function memory()
  local mem, stat = {}, io.open('/proc/meminfo', 'r')
  if stat then
    local names = {'MemFree', 'Cached', 'SwapCached', 'Active', 'Inactive'}
    for line in stat:lines() do
      for _, test in ipairs(names) do
        local size = line:match('^' .. test .. ":%s*(%d+)")
        if size then mem[test:sub(0, 1):lower()] = tonumber(size) end
      end
    end

    mem.c, mem.s = mem.c + mem.s, nil
    mem.f, mem.m = mem.m, nil

    stat:close()
  else
    local units = {
      K = 1,
      M = 1024,
      G = 1024 * 1024
    }

    for str in top.physmem:split("%s*,%s*") do
      local val, unit, type = str:match("(%d+)([KMG])%s+(%w)")
      mem[type] = val * units[unit]
    end

    mem.u = nil
  end

  return mem
end

opts = {
  bright = true,
  colors = 'ansi'
}

local function parseopts(opts)
  opts["-h,--help:print this help information"] = function()
    print("Usage: " .. arg[0]:gsub("/.*/", '') .. (opts.usage or " [options]"))

    local out, flaglen = {}, 0
    for opt, _ in pairs(opts) do
      local flags, msg = opt:match('(.-):(.*)')
      flags = (flags or opt):gsub(',', ', ')
      if #flags > flaglen then flaglen = #flags end
      out[flags] = msg or ''
    end

    for opt, msg in pairs(out) do
      print(opt .. (' '):rep(flaglen - #opt + 1) .. msg)
    end

    os.exit()
  end

  local variations, converters = {}, {
    id = function(_) return _ end,
    num = tonumber,
  }

  for opt, fun in pairs(opts) do
    opt = opt:match('(.*):') or opt

    for opt in opt:split(',') do
      local converter, extra, varopt = {'none', fun}

      varopt, extra = opt:match("(.-)=(%b<>)")
      if varopt then
        opt = varopt
        converter[1] = converters[extra:sub(2,-2) or 'id'] or converters.id
      end

      varopt = opt:match('%b[]')
      if varopt then
        variations[opt:gsub("%b[]", varopt:sub(2, -2))] = converter
        variations[opt:gsub("%b[]", '')] = converter
      else
        variations[opt] = converter
      end
    end
  end

  local skip = false
  for i, a in ipairs(arg) do
    if skip then skip = true; goto next end

    for var, _ in pairs(variations) do
      local conv, fun = table.unpack(_) 

      if a == var then
        if conv == 'none' then
          fun(var)
        else
          if not arg[i + 1] then print(var .. ': missing option argument'); os.exit(1) end
          skip = true
          fun(conv(arg[i + 1]), var)
        end
      end
    end

    -- used when next value is consumed by the current option
    ::next::
  end
end

local bars, history, mem, ordering, width = {}, {}, memory(), 'fwaic', 38
for i = 1, 8 do table.insert(bars, string.char(226, 150, 128 + i)) end

parseopts({
  ["--[no-]bright:use bright colors for cpu metrics"] = function(opt) opts.bright = opt == "--bright" end,
  ["--tmux:output using tmux colors"] = function() opts.colors = 'tmux' end,
  ["--width=<num>:width of output graph (default " .. width .. ")"] = function(opt) width = opt end,
  ["--order=<string>:order to show memory sections in (default " .. ordering .. ")"] = function(opt) ordering = opt end
})

-- Slightly overkill OS Environment access and setting but great for reuse
local ENV = {}
ffi.cdef [[
  char * getenv(const char *);
  int setenv(const char *, const char *, int);
]]
setmetatable(ENV, {
  __index = function(self, k)
    local val = ffi.string(getenv(k))
    rawset(self, k, val)
    return val
  end,
  __newindex = function(self, k, v)
    if setenv(k, v, 1) == 0 then rawset(self, k, v) end
  end
})

-- get the saved history, creating the storage if not created yet
local file = io.open(ENV.HOME .. '/.usage.dat', 'r')
if not file then
  file = io.open(ENV.HOME .. '/.usage.dat', 'w')
  file:close(); file = io.open(ENV.HOME .. '/.usage.dat', 'r')
end
for line in file:lines() do table.insert(history, tonumber(line)) end
file:close()

-- store the new usage value and remove old entries
history[#history + 1] = usage()
for i = 1, #history - width do table.remove(history, 1) end

local memscale = width / sum(mem)
local norm = (#bars - 1) / 1.0 -- math.max(table.unpack(history))

local colors, cmap = {
  green = {
    ansi = { bg = 42, fg = 32 },
    tmux = { },
  },
  bright_green = {
    ansi = { bg = 102, fg = 92 },
    tmux = { },
  },
  red = {
    ansi = { bg = 41, fg = 31 },
    tmux = {},
  },
  bright_red = {
    ansi = { bg = 101, fg = 91 },
    tmux = {},
  },
  yellow = {
    ansi = { bg = 43, fg = 33 },
    tmux = {},
  },
  bright_yellow = {
    ansi = { bg = 103, fg = 93 },
    tmux = {},
  },
  blue = {
    ansi = { bg = 44, fg = 34 },
    tmux = {},
  },
  bright_blue = {
    ansi = { bg = 104, fg = 94 },
    tmux = {},
  },
  cyan = {
    ansi = { bg = 46, fg = 36 },
    tmux = {},
  },
  bright_cyan = {
    ansi = { bg = 106, fg = 96 },
    tmux = {},
  },
}, {
  f = "green",
  w = "red",
  a = "yellow",
  i = "blue",
  c = "cyan",
}

for k, v in pairs(colors) do
  local tmux_color = k:gsub("_", '')
  colors[k].tmux.bg = "#[bg=" .. tmux_color .. "]"
  colors[k].tmux.fg = "#[fg=" .. tmux_color .. "]"
  colors[k].ansi.fg = "\27[" .. colors[k].ansi.fg .. "m"
  colors[k].ansi.bg = "\27[" .. colors[k].ansi.bg .. "m"
end

--[[
  From the end of the graph to be generated calculate the transitions between
  the colors for each memory slice. The transition point is then inserted into
  the history line as a table of color and cpu usages which can be detected
  when printing.
--]]
for i = 1, width - #history do table.insert(history, 1, 0) end
local idx = #history < width and width or #history
for str in ordering:reverse():gmatch("%w") do
  -- skip this memory attribute if the platform doesn't support it
  if not mem[str] then goto next end

  -- caculate the number of cpu usage ticks needed to represent this memory
  -- slice and jump back on graph to insert starting color point
  idx = idx - math.round(memscale * mem[str])

  -- ensure we don't go beyond the start of the graph because of rounding
  if idx < 1 then idx = 1 end

  local bg = colors[cmap[str]][opts.colors].bg
  local fg = colors[(opts.bright and 'bright_' or '') .. cmap[str]][opts.colors].fg
  history[idx] = {color = fg .. bg, usage = history[idx]}

  ::next::
end

local tmpfile = os.tmpname()
file = io.open(tmpfile, 'w')

for i, val in ipairs(history) do
  if type(val) == 'table' then
    io.stdout:write(val.color)
    val = val.usage
  end
  file:write(tostring(val) .. "\n")
  io.stdout:write(bars[math.round(norm * val) + 1])
end
file:close()
os.rename(tmpfile, ENV.HOME .. '/.usage.dat')

if opts.colors == 'ansi' then io.stdout:write("\27[0m") end

-- vim: set ft=lua:
