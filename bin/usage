#!/usr/bin/env luajit
shell = {}

function shell.escape(...)
 local command = type(...) == 'table' and ... or { ... }
 for i, s in ipairs(command) do
  s = (tostring(s) or ''):gsub('"', '\\"')
  if s:find '[^A-Za-z0-9_."/-]' then
   s = '"' .. s .. '"'
  elseif s == '' then
   s = '""'
  end
  command[i] = s
 end
 return table.concat(command, ' ')
end

function shell.lines(...)
 return assert(io.popen(shell.escape(...) .. ' 2>&1')):lines()
end

function string:split(pat)
  pat = pat or '%s+'
  local idx, g = 1, self:gmatch("()(" .. pat .. ")")
  local function next(start, seps, sep)
    idx = sep and seps + #sep
    return self:sub(start, (seps or 0) - 1)
  end
  return function() if idx then return next(idx, g()) end end
end

function math.round(val, step)
  step = step or 1
  return math.floor(((val + step / 2) / step) * step)
end

table.unpack = unpack or table.unpack
local ffi = require "ffi"
setmetatable(_G, {__index = ffi.C})
ffi.cdef "int usleep(uint64_t)"

local function sum(t)
  local sum = 0
  for i, val in pairs(t) do sum = sum + val end
  return sum
end

if ffi.os == 'OSX' then
  PROCESSOR_CPU_LOAD_INFO = 2
  HOST_VM_INFO = 2
  KERN_SUCCESS = 0

  -- mach header files really are a mess of typedefs to be pretty
  ffi.cdef [[
    typedef int integer_t;
    typedef unsigned int __darwin_natural_t;
    typedef __darwin_natural_t natural_t;
    typedef natural_t mach_port_name_t;
    typedef mach_port_name_t mach_port_t;

    typedef int kern_return_t;
    typedef mach_port_t host_t;
    typedef int processor_flavor_t;
    typedef integer_t * processor_info_array_t;
    typedef natural_t mach_msg_type_number_t;
    typedef mach_port_t vm_map_t;
    typedef natural_t vm_offset_t;
    typedef vm_offset_t vm_address_t;
    typedef natural_t vm_size_t;
    typedef integer_t host_flavor_t;
    typedef integer_t * host_info_t;

    mach_port_t mach_host_self();
    mach_port_t mach_task_self();

    /* Used to get information on processor usage */
    kern_return_t host_processor_info(host_t,
                                      processor_flavor_t,
                                      natural_t *,
                                      processor_info_array_t *,
                                      mach_msg_type_number_t *);

    /* host_processor_info returns an allocated object that must be freed */
    kern_return_t vm_deallocate(vm_map_t,
                                vm_address_t,
                                vm_size_t);

    /* This can return memory or load average data */
    kern_return_t host_statistics(host_t,
                                  host_flavor_t,
                                  host_info_t,
                                  mach_msg_type_number_t *);

    /**
     * These structures are mine and used for easy access to returned
     * information from the above calls.
     **/
    typedef struct {
      integer_t free;
      integer_t active;
      integer_t inactive;
      integer_t wire;
      integer_t unused[8]; // required otherwise call fails
    } vm_statistics;

    typedef struct {
      integer_t user;
      integer_t system;
      integer_t idle;
      integer_t nice;
    } cpu_statistics;
  ]]
end

local top = {}
setmetatable(top, {
  __index = function(self, k)
    for line in shell.lines{'top', '-R', '-F', '-l1', '-n0', '-s0'} do
      local key, value = line:match('^([%w%s]+):%s*(.+)')
      if key then self[key:lower()] = value end
    end

    -- don't call top again by accident
    setmetatable(self, {})

    return self[k]
  end
})

local cpu_usage = {
  OSX = function()
    local num_cpu = ffi.new("natural_t[1]")
    local cpu_info = ffi.new('cpu_statistics *[1]')
    local num_cpu_info = ffi.new("mach_msg_type_number_t[1]")

    local used, idle

    if host_processor_info(mach_host_self(),
                           PROCESSOR_CPU_LOAD_INFO,
                           num_cpu,
                           ffi.cast('processor_info_array_t *', cpu_info),
                           num_cpu_info) == KERN_SUCCESS then
      for i = 0, num_cpu[0] - 1 do
        used = cpu_info[0][i].user + cpu_info[0][i].system + cpu_info[0][i].nice
        idle = cpu_info[0][i].idle
      end

      if vm_deallocate(mach_task_self(),
                       ffi.cast('vm_address_t', cpu_info[0]),
                       ffi.sizeof('natural_t') * num_cpu_info[0]) ~= KERN_SUCCESS then

        io.stderr:write('Failed deallocating cpu info\n')
        os.exit(1)
      end
    end

    return idle, idle + used
  end,
  Linux = function()
    local stat, stats, total, idle = io.open('/proc/stat', 'r'), {}

    for line in stat:lines() do
      if line:find("^cpu%s+%d+") then
        for stat in line:split() do table.insert(stats, tonumber(stat)) end

        total, idle = sum(stats), stats[4]

        break
      end
      ::next::
    end

    stat:close()

    return idle, total
  end
}

local function usage()
  if cpu_usage[ffi.os] then
    local diff, prev = {}, {}

    for i = 1, 0, -1 do
      local idle, total = cpu_usage[ffi.os]()

      diff.idle = idle - (prev.idle or 0)
      diff.total = total - (prev.total or 0)
      diff.usage = (diff.total - diff.idle) / diff.total

      prev.idle, prev.total = diff.idle, diff.total

      usleep(i * 500000)
    end
    return diff.usage
  else
    for str in top["cpu usage"]:split("%s*,%s*") do
      local stat, name = str:match("([%d%.]+)%%%s+(%w+)")
      if name == "idle" then return 1 - stat / 100 end
    end
  end
end

local function memory()
  local mem, stat = {}, io.open('/proc/meminfo', 'r')
  if stat then
    local names = {'MemFree', 'Cached', 'SwapCached', 'Active', 'Inactive'}
    for line in stat:lines() do
      for _, test in ipairs(names) do
        local size = line:match('^' .. test .. ":%s*(%d+)")
        if size then mem[test:sub(0, 1):lower()] = tonumber(size) end
      end
    end

    mem.c, mem.s = mem.c + mem.s, nil
    mem.f, mem.m = mem.m, nil

    stat:close()
  elseif ffi.os == 'OSX' then
    local mem_info = ffi.new('vm_statistics')

    -- it is important to realize this value is in terms of natural_t, i.e. it
    -- takes sizeof(natural_t) times this number to get the number of bytes used
    local mem_info_count = ffi.new('mach_msg_type_number_t[1]',
                                    ffi.sizeof(mem_info) / ffi.sizeof('natural_t'))

    local err = host_statistics(mach_host_self(),
                                HOST_VM_INFO,
                                ffi.cast('host_info_t', mem_info),
                                mem_info_count)
    if err == KERN_SUCCESS then
      mem.f, mem.w = mem_info.free, mem_info.wire
      mem.a, mem.i = mem_info.active, mem_info.inactive
    else
      io.stderr:write("failed getting memory info\n")
      os.exit(1)
    end
  else
    local units = {
      K = 1,
      M = 1024,
      G = 1024 * 1024
    }

    for str in top.physmem:split("%s*,%s*") do
      local val, unit, type = str:match("(%d+)([KMG])%s+(%w)")
      mem[type] = val * units[unit]
    end

    mem.u = nil
  end

  return mem
end

opts = {
  bright = true,
  colors = 'ansi',
  order = 'fwaic',
  width = 38,
  rgb = false,
}

local function parseopts(opts)
  -- add a help option that prints the options of the program with help strings
  opts["-h,--help:print this help information"] = function()
    print("Usage: " .. arg[0]:gsub("/.*/", '') .. (opts.usage or " [options]"))

    local out, flaglen = {}, 0
    for opt in pairs(opts) do
      local flags, msg = opt:match('(.-):(.*)')
      flags = (flags or opt):gsub(',', ', ')
      if #flags > flaglen then flaglen = #flags end
      out[flags] = msg or ''
    end

    for opt, msg in pairs(out) do
      print(opt .. (' '):rep(flaglen - #opt + 1) .. msg)
    end

    os.exit()
  end

  local variations, converters = {}, {
    id = function(_) return _ end,
    num = function(_, name)
      local result = tonumber(_)
      if result then return result end
      io.stderr:write(name .. " takes a number\n")
      os.exit(1)
    end,
  }

  for opt, fun in pairs(opts) do
    -- only parse options, i.e. --? style options
    if opt:sub(1, 1) ~= '-' then goto next end

    -- remove the help text on the option
    opt = opt:match('(.*):') or opt

    for opt in opt:split(',') do
      local converter, extra, varopt = {'none', fun}

      -- see if option has an argument of a given format
      varopt, extra = opt:match("(.-)=(%b<>)")

      -- see if option has an argument with no given format, identity is assumed
      if not varopt then varopt, extra = opt:match("(.-)="), "<id>" end

      -- store if option requires argument with converting function
      if varopt then
        opt = varopt -- the rest of the loop needs the raw option without =<>
        converter[1] = converters[extra:sub(2,-2)] or converters.id
      end

      -- look to see if option has an optional part in [] that let the option
      -- vary, ex: --[no-]bright can be --bright or --no-bright
      varopt = opt:match('%b[]')
      if varopt then
        variations[opt:gsub("%b[]", varopt:sub(2, -2))] = converter
        variations[opt:gsub("%b[]", '')] = converter
      else
        variations[opt] = converter
      end
    end

    ::next::
  end

  local skip = false
  for i, a in ipairs(arg) do
    local opt, val = a:match("(.-)=(.*)")

    -- used when this value was consumed by the previous option
    if skip then skip = false; goto next end
    if val == '' then val = nil end

    for var, _ in pairs(variations) do
      if (opt or a) == var then
        local conv, fun = table.unpack(_)
        if conv == 'none' then
          fun(var)
        else
          if not val and arg[i + 1] then val = arg[i + 1] end
          if not val then print(var .. ': missing option argument'); os.exit(1) end
          skip = true
          fun(conv(val, var), var)
        end
      end
    end

    ::next::
  end
end

local bars, history, mem = {}, {}, memory()
for i = 1, 8 do table.insert(bars, string.char(226, 150, 128 + i)) end

parseopts({
  ["--[no-]bright:use bright colors for cpu metrics"] = function(opt) opts.bright = opt == "--bright" end,
  ["--tmux:output using tmux colors"] = function() opts.colors = 'tmux' end,
  ["--width=<num>:width of output graph (default " .. opts.width .. ")"] = function(opt) opts.width = opt end,
  ["--order=<string>:order to show memory sections in (default " .. opts.order .. ")"] = function(opt) opts.order = opt end,
  ["--rgb=<num>:use 256 color palette to render foreground with 1..5 \z
  intensity (try 4)"] = function(_) opts.rgb = _ end
})

-- Slightly overkill OS Environment access and setting but great for reuse
local ENV = {}
ffi.cdef [[
  char * getenv(const char *);
  int setenv(const char *, const char *, int);
]]
setmetatable(ENV, {
  __index = function(self, k)
    local val = ffi.string(getenv(k))
    rawset(self, k, val)
    return val
  end,
  __newindex = function(self, k, v)
    if setenv(k, v, 1) == 0 then rawset(self, k, v) end
  end
})

-- get the saved history, creating the storage if not created yet
local file = io.open(ENV.HOME .. '/.usage.dat', 'r')
if not file then
  file = io.open(ENV.HOME .. '/.usage.dat', 'w')
  file:close(); file = io.open(ENV.HOME .. '/.usage.dat', 'r')
end
for line in file:lines() do table.insert(history, tonumber(line)) end
file:close()

-- store the new usage value and remove old entries
history[#history + 1] = usage()
for i = 1, #history - opts.width do table.remove(history, 1) end

local memscale = opts.width / sum(mem)
local norm = (#bars - 1) / 1.0 -- math.max(table.unpack(history))

local colors, cmap = {
  green         = {
    ansi = { bg = 42, fg  = 32 },
    rgb = { 0, 1, 0 },
  },
  bright_green  = { ansi = { bg = 102, fg = 92 },
  },
  red           = {
    ansi = { bg = 41, fg  = 31 },
    rgb = { 1, 0, 0 },
  },
  bright_red    = { ansi = { bg = 101, fg = 91 }, },
  yellow        = {
    ansi = { bg = 43, fg  = 33 },
    rgb = { 1, 1, 0 },
  },
  bright_yellow = { ansi = { bg = 103, fg = 93 }, },
  blue          = {
    ansi = { bg = 44, fg  = 34 },
    rgb = { 0, 0, 1 }
  },
  bright_blue   = { ansi = { bg = 104, fg = 94 }, },
  cyan          = {
    ansi = { bg = 46, fg  = 36 },
    rgb = { 0, 1, 1 }
  },
  bright_cyan   = { ansi = { bg = 106, fg = 96 }, },
}, {
  f = "green",
  w = "red",
  a = "yellow",
  i = "blue",
  c = "cyan",
}

for k, v in pairs(colors) do
  local tmux_color, color = k:gsub("_", ''), colors[k].rgb
  colors[k].tmux = {}

  if opts.rgb and color then
    local fg = 16 + 36 * color[1] * opts.rgb + 6 * color[2] * opts.rgb + color[3] * opts.rgb
    colors[k].tmux.fg = "#[fg=colour" .. fg .. "]"
    colors[k].ansi.fg = "\27[38;5;" .. fg .. "m"
  else
    colors[k].tmux.fg ="#[fg=" .. tmux_color .. "]"
    colors[k].ansi.fg = "\27[" .. colors[k].ansi.fg .. "m"
  end

  colors[k].tmux.bg = "#[bg=" .. tmux_color .. "]"
  colors[k].ansi.bg = "\27[" .. colors[k].ansi.bg .. "m"
end

--[[
  From the end of the graph to be generated calculate the transitions between
  the colors for each memory slice. The transition point is then inserted into
  the history line as a table of color and cpu usages which can be detected
  when printing.
--]]
for i = 1, opts.width - #history do table.insert(history, 1, 0) end
local idx = #history < opts.width and opts.width or #history
for str in opts.order:reverse():gmatch("%w") do
  -- skip this memory attribute if the platform doesn't support it
  if not mem[str] then goto next end

  -- caculate the number of cpu usage ticks needed to represent this memory
  -- slice and jump back on graph to insert starting color point
  idx = idx - math.round(memscale * mem[str])

  -- ensure we don't go beyond the start of the graph because of rounding
  if idx < 1 then idx = 1 end

  local bg, fg = (colors[cmap[str]][opts.colors].bg)
  fg = opts.rgb and '' or opts.bright and 'bright_' or ''
  fg = colors[fg .. cmap[str]][opts.colors].fg
  history[idx] = {color = fg .. bg, usage = history[idx]}

  ::next::
end

local tmpfile = os.tmpname()
file = io.open(tmpfile, 'w')

for i, val in ipairs(history) do
  if type(val) == 'table' then
    io.stdout:write(val.color)
    val = val.usage
  end
  file:write(tostring(val) .. "\n")
  io.stdout:write(bars[math.round(norm * val) + 1])
end
file:close()
os.rename(tmpfile, ENV.HOME .. '/.usage.dat')

if opts.colors == 'ansi' then io.stdout:write("\27[0m") end

-- vim: set ft=lua:
