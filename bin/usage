#!/usr/bin/env luajit
shell = {}

function shell.escape(...)
 local command = type(...) == 'table' and ... or { ... }
 for i, s in ipairs(command) do
  s = (tostring(s) or ''):gsub('"', '\\"')
  if s:find '[^A-Za-z0-9_."/-]' then
   s = '"' .. s .. '"'
  elseif s == '' then
   s = '""'
  end
  command[i] = s
 end
 return table.concat(command, ' ')
end

function shell.lines(...)
 return assert(io.popen(shell.escape(...) .. ' 2>&1')):lines()
end

function string:split(pat)
  pat = pat or '%s+'
  local idx, g = 1, self:gmatch("()(" .. pat .. ")")
  local function next(start, seps, sep)
    idx = sep and seps + #sep
    return self:sub(start, (seps or 0) - 1)
  end
  return function() if idx then return next(idx, g()) end end
end

function math.round(val, step)
  step = step or 1
  return math.floor(((val + step / 2) / step) * step)
end

table.unpack = unpack or table.unpack
local ffi = require "ffi"
setmetatable(_G, {__index = ffi.C})
ffi.cdef "int usleep(uint64_t)"

local function sum(t)
  local sum = 0
  for i, val in pairs(t) do sum = sum + val end
  return sum
end

local top = {}
setmetatable(top, {
  __index = function(self, k)
    for line in shell.lines{'top', '-R', '-F', '-l1', '-n0', '-s0'} do
      local key, value = line:match('^([%w%s]+):%s*(.+)')
      if key then self[key:lower()] = value end
    end

    -- don't call top again by accident
    setmetatable(self, {})

    return self[k]
  end
})

local function usage()
  local stat = io.open('/proc/stat', 'r')
  if stat then
    local diff, prev = {}, {}

    for i = 1, 0, -1 do
      for line in stat:lines() do
        local cpu, stats = line:find("^cpu%s+%d+")
        if not cpu then goto next end

        stats = {}
        for stat in line:split() do table.insert(stats, tonumber(stat)) end

        diff.idle = stats[4] - (prev.idle or 0)
        diff.total = sum(stats) - (prev.total or 0)
        diff.usage = (diff.total - diff.idle) / diff.total

        prev.idle, prev.total = diff.idle, diff.total

        ::next::
        break
      end

      usleep(i * 1000000)
      stat:seek('set', 0)
    end

    stat:close()
    return diff.usage
  else
    for str in top["cpu usage"]:split("%s*,%s*") do
      local stat, name = str:match("([%d%.]+)%%%s+(%w+)")
      if name == "idle" then return 1 - stat / 100 end
    end
  end
end

local function memory()
  local mem, stat = {}, io.open('/proc/meminfo', 'r')
  if stat then
    local names = {'MemFree', 'Cached', 'SwapCached', 'Active', 'Inactive'}
    for line in stat:lines() do
      for _, test in ipairs(names) do
        local size = line:match('^' .. test .. ":%s*(%d+)")
        if size then mem[test:sub(0, 1):lower()] = tonumber(size) end
      end
    end

    mem.c, mem.s = mem.c + mem.s, nil
    mem.f, mem.m = mem.m, nil

    stat:close()
  else
    local units = {
      K = 1,
      M = 1024,
      G = 1024 * 1024
    }

    for str in top.physmem:split("%s*,%s*") do
      local val, unit, type = str:match("(%d+)([KMG])%s+(%w)")
      mem[type] = val * units[unit]
    end

    mem.u = nil
  end

  return mem
end

opts = {
  bright = true,
  colors = 'ansi',
  order = 'fwaic',
  width = 38,
}

local function parseopts(opts)
  -- add a help option that prints the options of the program with help strings
  opts["-h,--help:print this help information"] = function()
    print("Usage: " .. arg[0]:gsub("/.*/", '') .. (opts.usage or " [options]"))

    local out, flaglen = {}, 0
    for opt in pairs(opts) do
      local flags, msg = opt:match('(.-):(.*)')
      flags = (flags or opt):gsub(',', ', ')
      if #flags > flaglen then flaglen = #flags end
      out[flags] = msg or ''
    end

    for opt, msg in pairs(out) do
      print(opt .. (' '):rep(flaglen - #opt + 1) .. msg)
    end

    os.exit()
  end

  local variations, converters = {}, {
    id = function(_) return _ end,
    num = tonumber,
  }

  for opt, fun in pairs(opts) do
    -- only parse options, i.e. --? style options
    if opt:sub(1, 1) ~= '-' then goto next end

    -- remove the help text on the option
    opt = opt:match('(.*):') or opt

    for opt in opt:split(',') do
      local converter, extra, varopt = {'none', fun}

      -- see if option has an argument of a given format
      varopt, extra = opt:match("(.-)=(%b<>)")

      -- see if option has an argument with no given format, identity is assumed
      if not varopt then varopt, extra = opt:match("(.-)="), "<id>" end

      -- store if option requires argument with converting function
      if varopt then
        opt = varopt -- the rest of the loop needs the raw option without =<>
        converter[1] = converters[extra:sub(2,-2)] or converters.id
      end

      -- look to see if option has an optional part in [] that let the option
      -- vary, ex: --[no-]bright can be --bright or --no-bright
      varopt = opt:match('%b[]')
      if varopt then
        variations[opt:gsub("%b[]", varopt:sub(2, -2))] = converter
        variations[opt:gsub("%b[]", '')] = converter
      else
        variations[opt] = converter
      end
    end

    ::next::
  end

  local skip = false
  for i, a in ipairs(arg) do
    -- used when this value was consumed by the previous option
    if skip then skip = false; goto next end

    for var, _ in pairs(variations) do
      if a == var then
        local conv, fun = table.unpack(_)
        if conv == 'none' then
          fun(var)
        else
          if not arg[i + 1] then print(var .. ': missing option argument'); os.exit(1) end
          skip = true
          fun(conv(arg[i + 1]), var)
        end
      end
    end

    ::next::
  end
end

local bars, history, mem = {}, {}, memory()
for i = 1, 8 do table.insert(bars, string.char(226, 150, 128 + i)) end

parseopts({
  ["--[no-]bright:use bright colors for cpu metrics"] = function(opt) opts.bright = opt == "--bright" end,
  ["--tmux:output using tmux colors"] = function() opts.colors = 'tmux' end,
  ["--width=<num>:width of output graph (default " .. opts.width .. ")"] = function(opt) opts.width = opt end,
  ["--order=<string>:order to show memory sections in (default " .. opts.order .. ")"] = function(opt) opts.order = opt end
})

-- Slightly overkill OS Environment access and setting but great for reuse
local ENV = {}
ffi.cdef [[
  char * getenv(const char *);
  int setenv(const char *, const char *, int);
]]
setmetatable(ENV, {
  __index = function(self, k)
    local val = ffi.string(getenv(k))
    rawset(self, k, val)
    return val
  end,
  __newindex = function(self, k, v)
    if setenv(k, v, 1) == 0 then rawset(self, k, v) end
  end
})

-- get the saved history, creating the storage if not created yet
local file = io.open(ENV.HOME .. '/.usage.dat', 'r')
if not file then
  file = io.open(ENV.HOME .. '/.usage.dat', 'w')
  file:close(); file = io.open(ENV.HOME .. '/.usage.dat', 'r')
end
for line in file:lines() do table.insert(history, tonumber(line)) end
file:close()

-- store the new usage value and remove old entries
history[#history + 1] = usage()
for i = 1, #history - opts.width do table.remove(history, 1) end

local memscale = opts.width / sum(mem)
local norm = (#bars - 1) / 1.0 -- math.max(table.unpack(history))

local colors, cmap = {
  green         = { ansi = { bg = 42, fg  = 32 }, },
  bright_green  = { ansi = { bg = 102, fg = 92 }, },
  red           = { ansi = { bg = 41, fg  = 31 }, },
  bright_red    = { ansi = { bg = 101, fg = 91 }, },
  yellow        = { ansi = { bg = 43, fg  = 33 }, },
  bright_yellow = { ansi = { bg = 103, fg = 93 }, },
  blue          = { ansi = { bg = 44, fg  = 34 }, },
  bright_blue   = { ansi = { bg = 104, fg = 94 }, },
  cyan          = { ansi = { bg = 46, fg  = 36 }, },
  bright_cyan   = { ansi = { bg = 106, fg = 96 }, },
}, {
  f = "green",
  w = "red",
  a = "yellow",
  i = "blue",
  c = "cyan",
}

for k, v in pairs(colors) do
  local tmux_color = k:gsub("_", '')
  colors[k].tmux = { bg = "#[bg=" .. tmux_color .. "]",
                     fg = "#[fg=" .. tmux_color .. "]" }
  colors[k].ansi.fg = "\27[" .. colors[k].ansi.fg .. "m"
  colors[k].ansi.bg = "\27[" .. colors[k].ansi.bg .. "m"
end

--[[
  From the end of the graph to be generated calculate the transitions between
  the colors for each memory slice. The transition point is then inserted into
  the history line as a table of color and cpu usages which can be detected
  when printing.
--]]
for i = 1, opts.width - #history do table.insert(history, 1, 0) end
local idx = #history < opts.width and opts.width or #history
for str in opts.order:reverse():gmatch("%w") do
  -- skip this memory attribute if the platform doesn't support it
  if not mem[str] then goto next end

  -- caculate the number of cpu usage ticks needed to represent this memory
  -- slice and jump back on graph to insert starting color point
  idx = idx - math.round(memscale * mem[str])

  -- ensure we don't go beyond the start of the graph because of rounding
  if idx < 1 then idx = 1 end

  local bg = colors[cmap[str]][opts.colors].bg
  local fg = colors[(opts.bright and 'bright_' or '') .. cmap[str]][opts.colors].fg
  history[idx] = {color = fg .. bg, usage = history[idx]}

  ::next::
end

local tmpfile = os.tmpname()
file = io.open(tmpfile, 'w')

for i, val in ipairs(history) do
  if type(val) == 'table' then
    io.stdout:write(val.color)
    val = val.usage
  end
  file:write(tostring(val) .. "\n")
  io.stdout:write(bars[math.round(norm * val) + 1])
end
file:close()
os.rename(tmpfile, ENV.HOME .. '/.usage.dat')

if opts.colors == 'ansi' then io.stdout:write("\27[0m") end

-- vim: set ft=lua:
